---
layout: post
title: 初学JVM之问答式记住java自动内存管理
category: 技术
tags: VM
keywords: 
description:  
---


### 提问方式记住关键知识点

1. 为什么局部变量是线程安全的？

    因为在java内存模型中，虚拟机栈是线程私有的，而虚拟机栈描述的是java方法执行的内存模型：每个方法在执行同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等。因为局部变量是存在虚拟机栈中的，因此属于线程私有的，也就是线程安全的了。

2. 那局部变量表中存放的都有什么？

    各种基本数据类型、对象引用和returnAddress类型，局部变量表所需空间是在编译器分配的，因此在进入一个方法时，局部变量的空间是确定的，而且在方法运行期间不会改变。

3. JVM规范中规定的虚拟机栈的几种异常情况，并分别是在什么情况下发生的？

    两种。StackOverFlowError异常，是因为线程请求的栈深度超出了虚拟机所允许的深度，造成栈溢出错误；OutOfMemoryError异常，是因为虚拟机栈动态扩展时无法申请到足够的内容导致的内存超出错误。

4. 本地方法栈和虚拟机栈的区别

    - 虚拟机栈为虚拟机执行java方法服务。

    - 本地方法栈是虚拟机使用到的native方法服务。

5. 本地方法栈会抛出什么异常？

    同虚拟机栈一样，会抛出StackOverFlowError和OutOfMemoryError两种异常。

6. 现阶段对象分配情况？

    起初在JIT编译器和逃逸分析技术成熟之前，所有对象实例和数组都要在堆上分配，而随着JIT和逃逸分析技术的成熟，栈上分配、标量替换优化技术使得部分对象不再分配在堆上。

7. 垃圾处理器管理的区域？

    java堆区是GC管理的主要区域，即GC堆。因为收集器采用分代收集算法，因此java堆还细分为新生代和老生代；更细点：Eden空间、From Survivor空间、To Survivor空间。从内存分配角度堆还会分出多个线程私有的分配缓存区（TLAB[Thread Local Allocation Buffer]）

8. 方法区简介？

    方法区又叫（Non-Heap）非堆，是各个线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。叫非堆是为了与java堆区分。又被成为“永久代”，JDK1.8中正逐步采用Native memory实现方法区规划，将class metadata存储在叫MetaSpace的Native Memory中。

9. 运行时常量池介绍？

    运行时常量池是方法区的一部分，会存放编译器生成的各种字面量和符号引用，除了存储编译期常量，还可以在运行时将新的常量放入池内，如String.intern()方法。超出内存限制会报OutOfMemoryError异常

10. 直接内存

    就是不受JVM规范定义的内存区域，jdk1.4中加入的NIO就是使用了该方式，减少了java对和native堆来回复制数据，显著提高性能。

11. 对象创建时内存分配，及如何创建对象?

    主要通过指针碰撞和空闲列表两种方式。在使用Serial,ParNew等带有Compact过程的收集器时，使用分配方法是指针碰撞，而使用CMS这种基于Mark-Sweep算法收集器时，通常采用空闲列表。使用哪种分配方式取决于java堆是否规整，而java堆的规整取决于采用哪种垃圾收集器。

    在分配内存时会存在线程安全问题，有两种解决方案：虚拟机采用CAS并配上失败重试保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间进行，即每个线程都在堆上分配小块内存（TLAB）。

    为对象分配内存后，内存空间被初始化为零值，并且虚拟机还要对对象进行必要的设置：这些设置存放在对象头（Object header）中。完成后还会执行init方法按照程序员的意愿进行初始化。初始化完后对象才算真正创建成功。

12. 对象内存布局是怎样的？

    对象内存布局分为：

    - 对象头（包含两部分）

        第一部分：存储对象自身的运行时数据（HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳），被称为“Mark Word”

        第二部分：类型指针（对象指向类元数据的指针），虚拟机通过类型指针确定对象所属类。但非所有虚拟机都通过对象本身查找对象的元数据。如果通过句柄方式访问，从句柄池中就可以直接访问对象类型数据了。

        其他：对于数组对象，对象头中还必须记录数组长度，因为虚拟机从数组的元数据中无法确定数组大小，但可以确定java对象大小。

    - 实例数据

        代码中定义的字段内容（包括从父类继承的）。

        影响因素：虚拟机分配策略参数、字段在java源码中的定义顺序。

        虚拟机默认分配策略：longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointer)。相同宽度的字段总分配在一起，所以父类Filed可能会出现在子类Field之前；如果CompactFields(压缩属性)为true，子类的较窄变量会插入到父类变量缝隙中。

    - 对齐填充（可选）

        占位符作用，填充数据使得实例数据部分对齐。**因为对象起始地址必须为8字节的整数倍，也就是对象大小必须为8字节整数倍。**

13. 对象是怎么定位的？

    通过栈上的reference数据（堆上具体对象的地址）操作堆（虚拟机堆）上的具体对象，而访问方式取决于虚拟机的实现。主流有两种方式

    - 使用句柄方式

        java堆会创建句柄池，而reference存储的是句柄地址。句柄中就包含了分别指向对象实例数据和对象类型数据的具体指针地址信息。也就是reference先访问句柄，然后根据句柄信息再访问到具体的对象实例或对象类型信息。


    - 直接指针方式

        reference中存储的具体对象的指针地址，如果访问对象的类型信息，需要根据对象头中的类型指针访问方法区的对象类型数据。

**对比：**

    句柄方式使得reference存储的稳定的句柄地址，对象的移动只会改变句柄中的实例数据指针。

    直接指针方式速度快，节省一次访问句柄的指针定位时间开销，而java对象访问频繁，这样积少成多也是很可观的执行成本。而Sun HotSpot就是使用的直接指针方式。


14. 为什么类对象的域有默认值而局部变量没有？

    因为虚拟机在创建对象时，对分配到的内存值都初始化为0，而局部变量是不会在内存中赋初始值的。

