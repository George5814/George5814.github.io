---
layout:  post
title: 深入分析 Volatile 的实现原理
category: 技术
tags: Java
keywords: 
description: 深入分析 Volatile 的实现原理

---

## Volatile 的官方定义

Java 语言规范第三版中对 volatile 的定义如下： java 编程语言允许线程访问共享变量，为了确保共享变量能被**准确和一致的更新**，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成 volatile，java 线程内存模型确保所有线程看到这个变量的值是一致的。

## 什么情况下可使用 volatile

1. 在多线程并发编程时，为了保持共享变量在多个线程的一致性。 =》 可见性
2. 为了保证代码执行按编码的顺序执行。  =》 有序性

并发编程中的三个特性：原子性，有序性和可见性。volatile就作用了其中的两个。

## 为什么使用 volatile

恰当的使用，它的使用和执行成本比synchronized更低，因为不会引起线程上下文的切换和调度。

## volatile的实现原理是什么

volatile 是依赖于硬件层面的支持，即需要 CPU 的指定来实现。

对于volatile修饰的变量，在汇编语言层面会多一行指令 `0x01a3de24: lock addl $0x0,(%esp);`。而该`lock`指令通过查IA-32架构可知主要做两件事 ：
1. 将当前处理器缓存行的数据写回到系统内存中。
2. 该写回内存操作会引起其他CPU里缓存了该内存地址的数据失效。 =》 CPU 的嗅探机制。

详细原理如下：

处理器为了提高处理速度，不直接和内存进行通讯，而是**先将系统内存的数据读到内部缓存（L1,L2 或其他）后再进行操作，但操作完之后不知道何时会写到内存**，如果对**声明了 Volatile 变量**进行写操作，**JVM 就会向处理器发送一条 Lock 前缀的指令**，将这个变量所在缓存行的数据写回到系统内存。

但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，**为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议**，每个**处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了**，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设**置成无效状态**，当处理器要对这个数据进行修改操作的时候，会**强制重新从系统内存里把数据读到处理器缓存里**。

### LOCK 前缀指令的改进

**Lock 前缀指令会引起处理器缓存回写到内存。** Lock 前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号，在该信号期间，会独占使用任何共享内存

1. 第一阶段：
   1. LOCK指令会**锁住总线**，导致其他的处理器不能访问总线，也就不能访问系统内存。将多线程的并发变成了串行执行。
2. 优化后
   1. LOCK指令不再锁总线，而是**锁缓存行**。并将数据会写到该缓存，**使用缓存一致性来保证原子性**。

**缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。**

新的 CPU 会使用 MESI（修改，独占，共享，无效）控制协议来维护内部缓存和其他处理器的缓存的一致性。

可以看出硬件技术的进步对于软件的性能提升有质的飞越。

## volatile在软件层面的优化

并发编程大师 Doug lea在 JDK1.7 中新增了队列集合类 LinkedTransferQueue，在使用Volatile时用**追价字节**的方式优化队列出栈和入栈的性能。

### 为什么追加 64 字节能够提高并发编程的效率呢？


因为对于英特尔酷睿 i7，酷睿， Atom 和 NetBurst， Core Solo 和 Pentium M 处理器的 **L1，L2 或 L3 缓存的高速缓存行是 64 个字节宽，不支持部分填充缓存行，这意味着如果队列的头节点和尾节点都不足 64 字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头尾节点，当一个处理器试图修改头接点时会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作是需要不停修改头接点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea 使用追加到 64 字节的方式来填满高速缓冲区的缓存行，避免头接点和尾节点加载到同一个缓存行，使得头尾节点在修改时不会互相锁定。**  

上一段话核心意思是： **队列A的尾节点和队列B的头节点 在同一缓存行，队列 B 修改头节点时会锁住整个缓存行，导致队列A 不能访问自己的尾节点。因此需要补全 64 字节，让尾节点独占一个缓存行。**



该方式是对空间和性能的一个折中和取巧方案。如果并发较大，修改比较频繁，可以使用该方式。**主要是为了避免相互锁定**

那什么情况下不适合呢？
1. 缓存行非 64 字节宽的处理器。比较老一些的处理器，如 P6 和奔腾处理器的缓存行是 32 字节宽。
2. 共享变量不会被频繁的写，因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，共享变量如果不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。

## 感想

越底层的知识越基础越重要。CPU 和内存，磁盘的交互机制不了解，就不能很好的在软件层面利用硬件能力进行性能提升。

## 附上执行指令和 volatile 执行原理图

![CPU 的执行指令](//raw.githubusercontent.com/George5814/blog-pic/master/image/java/jmm-atomic-cmd.png)

![volatile 执行原理图](//raw.githubusercontent.com/George5814/blog-pic/master/image/java/volatile-principle.png)


## 参考文献
> https://www.infoq.cn/article/ftf-java-volatile