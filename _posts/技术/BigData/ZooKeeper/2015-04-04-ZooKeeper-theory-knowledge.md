---
layout: post
title: ZooKeeper理论知识
category: 技术
tags: ZooKeeper
keywords: 
description: 初识ZooKeeper
---
 
 
{:toc}


### 1.	简介
	zookeeper是Google的Chubby的一个开源实现，是hadoop的分布式协调服务

ZooKeeper的是分布式应用的分布式，开放源码的协调服务。它公开了一套简单的分布式应用程序可以建立在为同步，配置维护，组服务和命名实施更高级别的服务原语集。它被设计为易于编程，使用熟悉的文件系统目录树结构风格的数据模型。它运行在Java中，并支持Java和C。
	
协调服务是出了名很难得到正确。它们特别容易出错，如竞态条件和死锁。背后的ZooKeeper的动机是缓解分布式应用程序从头开始实施协调服务的责任。

### 2.	Zk的设计目标

- a.简单化：

通过共享体系的命名空间进行协调，与文件系统相似，有一些数据寄存器组成，被称为Znode，与文件和目录类似。与典型的文件系统不同的是，Zk的数据是放在内存中的，因此zk可以达到高吞吐量、低延迟。
Zk能用在大型、分布式的系统。
严格的序列访问控制意味者复杂的控制源可以用在客户端上。

- b.健壮性：

zk互相知道其他服务器存在。维护一个处于内存中的状态镜像，以及一个位于存储器中的交换日志和快照。只要大部分服务器可用，zk服务就可用。

客户端连接到一个单一的ZooKeeper服务器。客户机维护通过它发送请求时，获取响应，获取观看事件，并发送心脏跳动一个TCP连接。如果TCP连接到服务器断开，客户端将连接到不同的服务器。

- c.有序性：

zk为每次更新赋予一个版本号，全局有序。

- d.速度优势:

去读主要负载时尤其快，当读操作比写操作多时，性能会更好。

- e.Zk还有原子性、单系统镜像、可靠性和实效性特点。

### 3.数据模型和分级名字空间

ZooKeeper提供的namespace很像标准的文件系统，名称是用斜杠（/）分隔路径元素的序列。在ZooKeeper的名字空间中的每个节点由路径标识。

![分级名字空间](/public/pic/ZooKeeper/zookeeper12.jpg)

### 4.节点和临时节点

不像标准FS，ZooKeeper命名空间中的每一个Node节点都可以拥有其及其子节点的数据，就像那允许文件也是目录的FS。ZooKeeper的目标是要存储协调数据、状态信息、配置和本地信息等。所以存储在每个节点上的数据很少，在KB范围内。用术语ZNode可以更清楚的表达我们讨论的是ZooKeeper的数据节点

ZooKeeper保持了包含数据改变、ACL改变、时间戳的版本信息的stat结构。允许缓存验证和协调的更新。每次的znode数据的改变，版本号也会增长。

存储在一个空间的每个znode的数据被读出，并以原子写入。读取获得与znode相关联的所有数据字节和一个写替换所有的数据。每个节点都有限制谁可以做什么的访问控制列表（ACL）。

动物园管理员还具有临时节点的概念。这些znodes存在，只要创建该znode会话处于活动状态。当会议结束znode被删除。当你想实现短暂的节点是有用的[待定]。

### 5.有条件的更新和监控

ZooKeeper支持监控的概念，客户端可以设置一个znode上的监控，当znode改变时，触发器会被触发或删除。当触发器被触发时，客户端会收到znode改变的通知。

并且，如果客户端和一个ZooKeeper服务节点断开，客户端将接收本地通知。

### 6.担保

ZooKeeper的速度非常快，非常简单。因为它的目标，不过，是成为更复杂的服务，如同步的结构的基础上，提供了一组保证。这些是：

- 顺序一致性 - 从客户端的更新将在它们发送的顺序应用。

- 原子 - 更新成功或失败。没有部分结果。

- 单一系统映像 - 一个客户将看到相同的服务的认识，而它连接到服务器。

- 可靠性 - 一旦更新已被应用，它会从那个时候向前持续到客户端覆盖更新。

- 时效性 - 该系统的客户端视图保证是向上最新结合的一定时间内。

### 7.简单的API

一个动物园管理员的设计目标是提供一个非常简单的编程接口。其结果是，它仅支持这些操作：

- 创建
	在树中的位置创建一个节点

- 删除
	删除一个节点

- 存在
	判断节点是否存在

- 获取数据
	从一个节点读取数据

- 设置数据
	写入数据到节点

- 获取子节点
	检索节点的子节点的列表

- 同步
	等待要传播的数据

### 8.实现

![实现](/public/pic/ZooKeeper/zk-theory-zkcomponents.jpg)

ZooKeeper的组件显示的ZooKeeper服务的高层组件。与请求处理器外，各构成ZooKeeper服务的服务器进行复制其自身的各组成部分的副本。

### 9.用途

ZooKeeper的编程接口有意被设计的很简单，但你可以实现更高阶的操作，比如同步原语、组成员关系、所有权等等。

### 10.性能

ZooKeeper被设计用于高性能。

ZooKeeper的吞吐量读写比变化


![吞吐量读写比变化](/public/pic/ZooKeeper/zk-theory-zkperfRW-3.2.jpg)


### 11.可靠性

可靠性错误的存在

![吞吐量读写比变化](/public/pic/ZooKeeper/zk-theory-zkperfreliability.jpg)

### 12.	Zk可以用来保证数据在zk集群之间的数据的事务性的一致	(一般数据在2M以下)

![Zk可以用来保证数据在zk集群之间的数据的事务性的一致](/public/pic/ZooKeeper/zookeeper1.png)


### 13.	zookeeper进行leader选举 
 
**核心思想：**

- 1.首先创建EPHEMERAL目录节点，如”/election”;

- 2.每个zookeeper服务器在此目录下创建一个SEQUENCE|EPHEMERAL类型节点”如/election/n_”;

- 3.zookeeper将自动为每个zookeeper服务器分配一个比前面所分配的序号要大的序号，拥有最小编号的zookeeper服务器将成为leader。

	为了能在leader发生意外时，整个系统能选出leader，需要所有的follower都监视leader所对应节点，当leader故障时，leader对应的临时节点将会被删除，会触发所有监视的follower的watch，从而进行选举leader操作。
	缺点：这样的解决方案会导致`从众效应`。

**实现：**

每个follower为follower集群中对应着比自己节点序号小的节点中x序号最大的节点设置一个watch，只有当follower所设置的watch被触发时，他才进行leader操作，一般将其设置为集群的下一个leader。这样很快，因为每一leader选举几乎只涉及单个leaderfollower的操作

###  14.zookeeper锁服务

- a.zookeeper中完全分布的锁是全局存在的。
- b.zookeeper的锁机制(实现加锁)

	i.	zk调用create()，创建路径格式为”_locknode/lock_”的节点，此节点类型为sequence(连续)和ephemeral(临时)，创建节点为临时节点，所有节点连续编号“lock-i”格式
	
	ii.	在创建锁节点上调用getChildren()方法，以获取锁目录下的最小编号节点，并且不设置watch。
	
	iii.	步骤2获取的节点是步骤1中客户端创建的节点，此客户端会获得该种类型的锁，然后退出操作。
	
	iv.	客户端在锁目录上调用exists()方法,并设置watch来监视锁目录下序号相对自己次小的连续临时节点的状态。
	
	v.	如果监视节点状态发生变化，则跳转到步骤2，继续后续操作直到退出锁竞争。
	
	vi.	Zookeeper解锁简单，只需在步骤1中创建的临时节点删除即可。
	
**PS：**

- 1.一个客户端解锁后，将只可能有一个客户端获得锁，因此每个临时的连续节点对应一个客户端，并且节点间没有重叠；

- 2.在zookeeper锁机制中没有轮询和超时。

###  15.	BooKeeper

- 副本功能。

- 提供可靠的日志记录。
BooKeeper为每份日志提供了分布式存储，并且采用了大多数概念，就是说只要集群中大多数机器可用，那么该日志一直有效。

BooKeeper包含四个角色：账本(服务器)、账户(Ledger,账本中存储的一系列记录)、客户端(BooKeeper Client,允许APP在系统上进行操作，包括创建账户，写账户)、元数据存储服务(metadata storage service,存储关于账户和版本的信息) 
